# Serverless REST API with Lambda, API Gateway, and DynamoDB

This project provisions a serverless REST API using AWS Lambda, API Gateway, and DynamoDB via Terraform.

---

## Resource-by-Resource Explanation

### 1. DynamoDB Table (`aws_dynamodb_table.table`)
**Purpose:**
Creates a DynamoDB table to store items. Uses `pk` as the primary key and on-demand billing.
**Testing:**
- Check table in AWS Console or CLI.
- Add, query, and delete items using AWS CLI or SDK.

### 2. Lambda Function (`aws_lambda_function.fn`)
**Purpose:**
Defines the Lambda function for handling API requests (CRUD operations) via API Gateway. Uses Python 3.12 and interacts with DynamoDB using the AWS SDK (`boto3`).

**Deep Explanation:**
- The Lambda function is deployed from a ZIP file containing `lambda_function.py`.
- The handler is set to `lambda_function.handler`, which means AWS Lambda will look for a function named `handler` in the file `lambda_function.py`.
- The function receives events in the format generated by API Gateway HTTP API (payload v2.0), which includes `requestContext`, `http.method`, and query string parameters.
- For POST requests, the function expects a JSON body with at least an `id` field. It creates a new item in DynamoDB with a partition key `pk` and any additional fields.
- For GET requests, the function parses the query string for `id` and retrieves the item from DynamoDB. If not found, it returns a 404-style message.
- The environment variable `TABLE_NAME` is injected by Terraform and used to reference the correct DynamoDB table.
- The Lambda function uses the IAM role to access DynamoDB and CloudWatch logs securely.

**Testing:**
- Invoke Lambda via API Gateway (see curl examples below).
- Check CloudWatch logs for execution, errors, and event payloads.

### 3. CloudWatch Log Group (`aws_cloudwatch_log_group.lambda_lg`)
**Purpose:**
Stores logs from Lambda executions for debugging and monitoring.
**Testing:**
- View logs in AWS CloudWatch after Lambda invocation.

### 4. IAM Role for Lambda (`aws_iam_role.lambda_role`)
**Purpose:**
Allows Lambda to be executed and access AWS services securely.

**Deep Explanation:**
- The IAM role uses a trust policy to allow the Lambda service (`lambda.amazonaws.com`) to assume the role.
- This role is attached to the Lambda function and is required for any AWS API calls from within the function.
- Least-privilege principle: Only the necessary permissions for DynamoDB and logging are granted.

**Testing:**
- Confirm role is attached to Lambda in AWS Console.
- If Lambda fails to access AWS resources, check the role and attached policies.

### 5. IAM Policy for Lambda (`aws_iam_role_policy.lambda_inline`)
**Purpose:**
Grants Lambda permissions for DynamoDB and CloudWatch logging.

**Deep Explanation:**
- The inline policy allows the Lambda to create log streams and put log events in CloudWatch for observability.
- It also allows `PutItem` and `GetItem` actions on the specific DynamoDB table, enforcing least-privilege.
- The resource ARNs are dynamically set to the log group and DynamoDB table created by Terraform.

**Testing:**
- If Lambda fails to access DynamoDB or log, check policy for missing permissions.
- Review CloudWatch logs for access denied errors.

### 6. API Gateway HTTP API (`aws_apigatewayv2_api.http`)
**Purpose:**
Creates an HTTP API Gateway to expose Lambda as REST endpoints.

**Deep Explanation:**
- API Gateway HTTP API is a fully managed service that routes HTTP requests to backend integrations (Lambda in this case).
- The API is created with protocol type `HTTP` for modern RESTful APIs.
- Terraform manages the lifecycle, naming, and tags for the API resource.

**Testing:**
- Check API Gateway in AWS Console.
- Confirm endpoint is created and matches the expected URL output from Terraform.

### 7. API Gateway Integration (`aws_apigatewayv2_integration.lambda`)
**Purpose:**
Connects API Gateway routes to the Lambda function using AWS_PROXY integration.

**Deep Explanation:**
- The integration type `AWS_PROXY` means the full HTTP request is passed to Lambda, and Lambda's response is returned directly to the client.
- The integration URI is the Lambda function ARN.
- Payload format v2.0 provides a simplified event structure for Lambda.

**Testing:**
- Send requests to API endpoint; Lambda should execute and return HTTP responses.

### 8. API Gateway Route (`aws_apigatewayv2_route.items`)
**Purpose:**
Defines the `/items` route, supporting GET and POST methods.

**Deep Explanation:**
- The route key `ANY /items` means all HTTP methods (GET, POST, etc.) to `/items` are routed to the Lambda integration.
- The Lambda function internally distinguishes between GET and POST using the event payload.
- This design allows for a single Lambda to handle multiple HTTP verbs for a resource path.

**Testing:**
- Use `curl` or Postman to send requests to `/items` endpoint as shown in the examples below.

### 9. API Gateway Stage (`aws_apigatewayv2_stage.default`)
**Purpose:**
Creates the `$default` stage for auto-deployment of API changes.

**Deep Explanation:**
- The `$default` stage is automatically deployed and updated when changes are made to the API configuration.
- This simplifies deployment and testing, as the latest changes are always live at the same endpoint.

**Testing:**
- Access the API endpoint URL and test CRUD operations using curl or Postman.

### 10. Lambda Permission for API Gateway (`aws_lambda_permission.allow_apigw`)
**Purpose:**
Allows API Gateway to invoke the Lambda function securely.

**Deep Explanation:**
- This resource creates a permission statement on the Lambda function, allowing invocation from API Gateway only.
- The principal is set to `apigateway.amazonaws.com`, and the source ARN restricts invocation to the specific API Gateway instance.
- Without this, API Gateway would receive a 500 error due to lack of permission to invoke Lambda.

**Testing:**
- If API Gateway returns 500, check Lambda permissions and CloudWatch logs for invocation errors.

---

## How to Deploy and Test
**Important:**
After cloning this repo, you must manually create `function.zip` once before running `terraform plan` or `terraform apply`:
```
zip function.zip lambda_function.py
```
This ensures the ZIP file exists for Terraform's hash calculation. After the first run, any changes to `lambda_function.py` will be automatically zipped by Terraform during `terraform apply` (no manual zipping needed for updates).


### 1. Prepare Lambda Code
- Write your handler in `lambda_function.py` as follows:
  ```python
  import os, json, boto3
  table = boto3.resource("dynamodb").Table(os.environ["TABLE_NAME"])

  def handler(event, context):
    method = event.get("requestContext", {}).get("http", {}).get("method", "GET")
    # POST: expects JSON body with at least "id" field
    if method == "POST":
      body = json.loads(event.get("body") or "{}")
      item = {"pk": body.get("id", "id-"+context.aws_request_id), **body}
      table.put_item(Item=item)
      return {
        "statusCode": 201,
        "headers": {"Content-Type":"application/json"},
        "body": json.dumps(item)
      }
    # GET: expects query string ?id=...
    else:
      from urllib.parse import parse_qs
      q = parse_qs(event.get("rawQueryString") or "")
      pk = (q.get("id") or ["sample"])[0]
      resp = table.get_item(Key={"pk": pk})
      return {
        "statusCode": 200,
        "headers": {"Content-Type":"application/json"},
        "body": json.dumps(resp.get("Item") or {"message":"not found","pk":pk})
      }
  ```
- Zip the file manually:
  ```
  zip function.zip lambda_function.py
  ```
- Place `function.zip` in the same directory as your Terraform configuration.
- In your `aws_lambda_function` resource, set:
  ```hcl
  filename         = "function.zip"
  handler          = "lambda_function.handler"
  source_code_hash = filebase64sha256("function.zip")
  # This ensures Terraform detects ZIP changes and updates Lambda automatically
  ```

### 2. Deploy Infrastructure
- Initialize and apply Terraform:
  ```
  terraform init
  terraform apply
  ```

### 3. Find API Endpoint
- In AWS Console: API Gateway → Your API → Stages → $default → Invoke URL

### 4. Test CRUD Operations

After `terraform apply`, get the API endpoint:
```
API=$(terraform output -raw api_base_url)
```

**Test GET (default: id=sample):**
```
curl "$API/items"
```

**Test POST (create an item):**
```
curl -X POST "$API/items" \
  -H "Content-Type: application/json" \
  -d '{"id":"item-123","note":"hello from Thet"}'
```

**Test GET for the new item:**
```
curl "$API/items?id=item-123"
```

### 5. Check DynamoDB Table
- Verify items are created, updated, deleted as expected.

### 6. Check Lambda and API Gateway Logs
- Use CloudWatch to view logs for debugging and validation.

### 7. IAM Permissions
- If any operation fails, check IAM role and policy for missing permissions.

---

## Notes
- The Lambda function expects the environment variable `TABLE_NAME` to be set to your DynamoDB table name.
- The Lambda runtime (Python 3.12) includes `boto3` by default. If you use external dependencies, include them in the ZIP.
- Remove the `archive` provider and any `archive_file` data resources from Terraform if you zip manually.
- Using the `source_code_hash` argument is recommended to ensure Terraform detects changes in your ZIP file and updates the Lambda function automatically.
- For multi-file or dependency packaging, use:
  ```
  pip install -r requirements.txt -t ./package
  cd package
  zip -r ../function.zip .
  cd ..
  zip function.zip lambda_function.py
  ```

---

For questions or troubleshooting, see the resource-by-resource explanations above or reach out for help!
